{"version":3,"file":"parser-input.js","sourceRoot":"","sources":["../../../less/parser/parser-input.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar chunker_1 = tslib_1.__importDefault(require(\"./chunker\"));\r\nexports.default = (function () {\r\n    var // Less input string\r\n    input;\r\n    var // current chunk\r\n    j;\r\n    var // holds state for backtracking\r\n    saveStack = [];\r\n    var // furthest index the parser has gone to\r\n    furthest;\r\n    var // if this is furthest we got to, this is the probably cause\r\n    furthestPossibleErrorMessage;\r\n    var // chunkified input\r\n    chunks;\r\n    var // current chunk\r\n    current;\r\n    var // index of current chunk, in `input`\r\n    currentPos;\r\n    var parserInput = {};\r\n    var CHARCODE_SPACE = 32;\r\n    var CHARCODE_TAB = 9;\r\n    var CHARCODE_LF = 10;\r\n    var CHARCODE_CR = 13;\r\n    var CHARCODE_PLUS = 43;\r\n    var CHARCODE_COMMA = 44;\r\n    var CHARCODE_FORWARD_SLASH = 47;\r\n    var CHARCODE_9 = 57;\r\n    function skipWhitespace(length) {\r\n        var oldi = parserInput.i;\r\n        var oldj = j;\r\n        var curr = parserInput.i - currentPos;\r\n        var endIndex = parserInput.i + current.length - curr;\r\n        var mem = (parserInput.i += length);\r\n        var inp = input;\r\n        var c;\r\n        var nextChar;\r\n        var comment;\r\n        for (; parserInput.i < endIndex; parserInput.i++) {\r\n            c = inp.charCodeAt(parserInput.i);\r\n            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\r\n                nextChar = inp.charAt(parserInput.i + 1);\r\n                if (nextChar === '/') {\r\n                    comment = { index: parserInput.i, isLineComment: true };\r\n                    var nextNewLine = inp.indexOf('\\n', parserInput.i + 2);\r\n                    if (nextNewLine < 0) {\r\n                        nextNewLine = endIndex;\r\n                    }\r\n                    parserInput.i = nextNewLine;\r\n                    comment.text = inp.substr(comment.index, parserInput.i - comment.index);\r\n                    parserInput.commentStore.push(comment);\r\n                    continue;\r\n                }\r\n                else if (nextChar === '*') {\r\n                    var nextStarSlash = inp.indexOf('*/', parserInput.i + 2);\r\n                    if (nextStarSlash >= 0) {\r\n                        comment = {\r\n                            index: parserInput.i,\r\n                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),\r\n                            isLineComment: false\r\n                        };\r\n                        parserInput.i += comment.text.length - 1;\r\n                        parserInput.commentStore.push(comment);\r\n                        continue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {\r\n                break;\r\n            }\r\n        }\r\n        current = current.slice(length + parserInput.i - mem + curr);\r\n        currentPos = parserInput.i;\r\n        if (!current.length) {\r\n            if (j < chunks.length - 1) {\r\n                current = chunks[++j];\r\n                skipWhitespace(0); // skip space at the beginning of a chunk\r\n                return true; // things changed\r\n            }\r\n            parserInput.finished = true;\r\n        }\r\n        return oldi !== parserInput.i || oldj !== j;\r\n    }\r\n    parserInput.save = function () {\r\n        currentPos = parserInput.i;\r\n        saveStack.push({ current: current, i: parserInput.i, j: j });\r\n    };\r\n    parserInput.restore = function (possibleErrorMessage) {\r\n        if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {\r\n            furthest = parserInput.i;\r\n            furthestPossibleErrorMessage = possibleErrorMessage;\r\n        }\r\n        var state = saveStack.pop();\r\n        current = state.current;\r\n        currentPos = parserInput.i = state.i;\r\n        j = state.j;\r\n    };\r\n    parserInput.forget = function () {\r\n        saveStack.pop();\r\n    };\r\n    parserInput.isWhitespace = function (offset) {\r\n        var pos = parserInput.i + (offset || 0);\r\n        var code = input.charCodeAt(pos);\r\n        return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);\r\n    };\r\n    // Specialization of $(tok)\r\n    parserInput.$re = function (tok) {\r\n        if (parserInput.i > currentPos) {\r\n            current = current.slice(parserInput.i - currentPos);\r\n            currentPos = parserInput.i;\r\n        }\r\n        var m = tok.exec(current);\r\n        if (!m) {\r\n            return null;\r\n        }\r\n        skipWhitespace(m[0].length);\r\n        if (typeof m === 'string') {\r\n            return m;\r\n        }\r\n        return m.length === 1 ? m[0] : m;\r\n    };\r\n    parserInput.$char = function (tok) {\r\n        if (input.charAt(parserInput.i) !== tok) {\r\n            return null;\r\n        }\r\n        skipWhitespace(1);\r\n        return tok;\r\n    };\r\n    parserInput.$peekChar = function (tok) {\r\n        if (input.charAt(parserInput.i) !== tok) {\r\n            return null;\r\n        }\r\n        return tok;\r\n    };\r\n    parserInput.$str = function (tok) {\r\n        var tokLength = tok.length;\r\n        // https://jsperf.com/string-startswith/21\r\n        for (var i = 0; i < tokLength; i++) {\r\n            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\r\n                return null;\r\n            }\r\n        }\r\n        skipWhitespace(tokLength);\r\n        return tok;\r\n    };\r\n    parserInput.$quoted = function (loc) {\r\n        var pos = loc || parserInput.i;\r\n        var startChar = input.charAt(pos);\r\n        if (startChar !== '\\'' && startChar !== '\"') {\r\n            return;\r\n        }\r\n        var length = input.length;\r\n        var currentPosition = pos;\r\n        for (var i = 1; i + currentPosition < length; i++) {\r\n            var nextChar = input.charAt(i + currentPosition);\r\n            switch (nextChar) {\r\n                case '\\\\':\r\n                    i++;\r\n                    continue;\r\n                case '\\r':\r\n                case '\\n':\r\n                    break;\r\n                case startChar: {\r\n                    var str = input.substr(currentPosition, i + 1);\r\n                    if (!loc && loc !== 0) {\r\n                        skipWhitespace(i + 1);\r\n                        return str;\r\n                    }\r\n                    return [startChar, str];\r\n                }\r\n                default:\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Permissive parsing. Ignores everything except matching {} [] () and quotes\r\n     * until matching token (outside of blocks)\r\n     */\r\n    parserInput.$parseUntil = function (tok) {\r\n        var quote = '';\r\n        var returnVal = null;\r\n        var inComment = false;\r\n        var blockDepth = 0;\r\n        var blockStack = [];\r\n        var parseGroups = [];\r\n        var length = input.length;\r\n        var startPos = parserInput.i;\r\n        var lastPos = parserInput.i;\r\n        var i = parserInput.i;\r\n        var loop = true;\r\n        var testChar;\r\n        if (typeof tok === 'string') {\r\n            testChar = function (char) { return char === tok; };\r\n        }\r\n        else {\r\n            testChar = function (char) { return tok.test(char); };\r\n        }\r\n        do {\r\n            var nextChar = input.charAt(i);\r\n            if (blockDepth === 0 && testChar(nextChar)) {\r\n                returnVal = input.substr(lastPos, i - lastPos);\r\n                if (returnVal) {\r\n                    parseGroups.push(returnVal);\r\n                }\r\n                else {\r\n                    parseGroups.push(' ');\r\n                }\r\n                returnVal = parseGroups;\r\n                skipWhitespace(i - startPos);\r\n                loop = false;\r\n            }\r\n            else {\r\n                if (inComment) {\r\n                    if (nextChar === '*' &&\r\n                        input.charAt(i + 1) === '/') {\r\n                        i++;\r\n                        blockDepth--;\r\n                        inComment = false;\r\n                    }\r\n                    i++;\r\n                    continue;\r\n                }\r\n                switch (nextChar) {\r\n                    case '\\\\':\r\n                        i++;\r\n                        nextChar = input.charAt(i);\r\n                        parseGroups.push(input.substr(lastPos, i - lastPos + 1));\r\n                        lastPos = i + 1;\r\n                        break;\r\n                    case '/':\r\n                        if (input.charAt(i + 1) === '*') {\r\n                            i++;\r\n                            inComment = true;\r\n                            blockDepth++;\r\n                        }\r\n                        break;\r\n                    case '\\'':\r\n                    case '\"':\r\n                        quote = parserInput.$quoted(i);\r\n                        if (quote) {\r\n                            parseGroups.push(input.substr(lastPos, i - lastPos), quote);\r\n                            i += quote[1].length - 1;\r\n                            lastPos = i + 1;\r\n                        }\r\n                        else {\r\n                            skipWhitespace(i - startPos);\r\n                            returnVal = nextChar;\r\n                            loop = false;\r\n                        }\r\n                        break;\r\n                    case '{':\r\n                        blockStack.push('}');\r\n                        blockDepth++;\r\n                        break;\r\n                    case '(':\r\n                        blockStack.push(')');\r\n                        blockDepth++;\r\n                        break;\r\n                    case '[':\r\n                        blockStack.push(']');\r\n                        blockDepth++;\r\n                        break;\r\n                    case '}':\r\n                    case ')':\r\n                    case ']': {\r\n                        var expected = blockStack.pop();\r\n                        if (nextChar === expected) {\r\n                            blockDepth--;\r\n                        }\r\n                        else {\r\n                            // move the parser to the error and return expected\r\n                            skipWhitespace(i - startPos);\r\n                            returnVal = expected;\r\n                            loop = false;\r\n                        }\r\n                    }\r\n                }\r\n                i++;\r\n                if (i > length) {\r\n                    loop = false;\r\n                }\r\n            }\r\n        } while (loop);\r\n        return returnVal ? returnVal : null;\r\n    };\r\n    parserInput.autoCommentAbsorb = true;\r\n    parserInput.commentStore = [];\r\n    parserInput.finished = false;\r\n    // Same as $(), but don't change the state of the parser,\r\n    // just return the match.\r\n    parserInput.peek = function (tok) {\r\n        if (typeof tok === 'string') {\r\n            // https://jsperf.com/string-startswith/21\r\n            for (var i = 0; i < tok.length; i++) {\r\n                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        else {\r\n            return tok.test(current);\r\n        }\r\n    };\r\n    // Specialization of peek()\r\n    // TODO remove or change some currentChar calls to peekChar\r\n    parserInput.peekChar = function (tok) { return input.charAt(parserInput.i) === tok; };\r\n    parserInput.currentChar = function () { return input.charAt(parserInput.i); };\r\n    parserInput.prevChar = function () { return input.charAt(parserInput.i - 1); };\r\n    parserInput.getInput = function () { return input; };\r\n    parserInput.peekNotNumeric = function () {\r\n        var c = input.charCodeAt(parserInput.i);\r\n        // Is the first char of the dimension 0-9, '.', '+' or '-'\r\n        return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;\r\n    };\r\n    parserInput.start = function (str, chunkInput, failFunction) {\r\n        input = str;\r\n        parserInput.i = j = currentPos = furthest = 0;\r\n        // chunking apparently makes things quicker (but my tests indicate\r\n        // it might actually make things slower in node at least)\r\n        // and it is a non-perfect parse - it can't recognise\r\n        // unquoted urls, meaning it can't distinguish comments\r\n        // meaning comments with quotes or {}() in them get 'counted'\r\n        // and then lead to parse errors.\r\n        // In addition if the chunking chunks in the wrong place we might\r\n        // not be able to parse a parser statement in one go\r\n        // this is officially deprecated but can be switched on via an option\r\n        // in the case it causes too much performance issues.\r\n        if (chunkInput) {\r\n            chunks = (0, chunker_1.default)(str, failFunction);\r\n        }\r\n        else {\r\n            chunks = [str];\r\n        }\r\n        current = chunks[0];\r\n        skipWhitespace(0);\r\n    };\r\n    parserInput.end = function () {\r\n        var message;\r\n        var isFinished = parserInput.i >= input.length;\r\n        if (parserInput.i < furthest) {\r\n            message = furthestPossibleErrorMessage;\r\n            parserInput.i = furthest;\r\n        }\r\n        return {\r\n            isFinished: isFinished,\r\n            furthest: parserInput.i,\r\n            furthestPossibleErrorMessage: message,\r\n            furthestReachedEnd: parserInput.i >= input.length - 1,\r\n            furthestChar: input[parserInput.i]\r\n        };\r\n    };\r\n    return parserInput;\r\n});\r\n//# sourceMappingURL=parser-input.js.map"]}