{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../less/parser/parser.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar less_error_1 = tslib_1.__importDefault(require(\"../less-error\"));\r\nvar tree_1 = tslib_1.__importDefault(require(\"../tree\"));\r\nvar visitors_1 = tslib_1.__importDefault(require(\"../visitors\"));\r\nvar parser_input_1 = tslib_1.__importDefault(require(\"./parser-input\"));\r\nvar utils = tslib_1.__importStar(require(\"../utils\"));\r\nvar function_registry_1 = tslib_1.__importDefault(require(\"../functions/function-registry\"));\r\nvar atrule_syntax_1 = require(\"../tree/atrule-syntax\");\r\n//\r\n// less.js - parser\r\n//\r\n//    A relatively straight-forward predictive parser.\r\n//    There is no tokenization/lexing stage, the input is parsed\r\n//    in one sweep.\r\n//\r\n//    To make the parser fast enough to run in the browser, several\r\n//    optimization had to be made:\r\n//\r\n//    - Matching and slicing on a huge input is often cause of slowdowns.\r\n//      The solution is to chunkify the input into smaller strings.\r\n//      The chunks are stored in the `chunks` var,\r\n//      `j` holds the current chunk index, and `currentPos` holds\r\n//      the index of the current chunk in relation to `input`.\r\n//      This gives us an almost 4x speed-up.\r\n//\r\n//    - In many cases, we don't need to match individual tokens;\r\n//      for example, if a value doesn't hold any variables, operations\r\n//      or dynamic references, the parser can effectively 'skip' it,\r\n//      treating it as a literal.\r\n//      An example would be '1px solid #000' - which evaluates to itself,\r\n//      we don't need to know what the individual components are.\r\n//      The drawback, of course is that you don't get the benefits of\r\n//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\r\n//      and a smaller speed-up in the code-gen.\r\n//\r\n//\r\n//    Token matching is done with the `$` function, which either takes\r\n//    a terminal string or regexp, or a non-terminal function to call.\r\n//    It also takes care of moving all the indices forwards.\r\n//\r\nvar Parser = function Parser(context, imports, fileInfo, currentIndex) {\r\n    currentIndex = currentIndex || 0;\r\n    var parsers;\r\n    var parserInput = (0, parser_input_1.default)();\r\n    function error(msg, type) {\r\n        throw new less_error_1.default({\r\n            index: parserInput.i,\r\n            filename: fileInfo.filename,\r\n            type: type || 'Syntax',\r\n            message: msg\r\n        }, imports);\r\n    }\r\n    function expect(arg, msg) {\r\n        // some older browsers return typeof 'function' for RegExp\r\n        var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);\r\n        if (result) {\r\n            return result;\r\n        }\r\n        error(msg || (typeof arg === 'string'\r\n            ? \"expected '\".concat(arg, \"' got '\").concat(parserInput.currentChar(), \"'\")\r\n            : 'unexpected token'));\r\n    }\r\n    // Specialization of expect()\r\n    function expectChar(arg, msg) {\r\n        if (parserInput.$char(arg)) {\r\n            return arg;\r\n        }\r\n        error(msg || \"expected '\".concat(arg, \"' got '\").concat(parserInput.currentChar(), \"'\"));\r\n    }\r\n    function getDebugInfo(index) {\r\n        var filename = fileInfo.filename;\r\n        return {\r\n            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\r\n            fileName: filename\r\n        };\r\n    }\r\n    /**\r\n     *  Used after initial parsing to create nodes on the fly\r\n     *\r\n     *  @param {String} str          - string to parse\r\n     *  @param {Array}  parseList    - array of parsers to run input through e.g. [\"value\", \"important\"]\r\n     *  @param {Number} currentIndex - start number to begin indexing\r\n     *  @param {Object} fileInfo     - fileInfo to attach to created nodes\r\n     */\r\n    function parseNode(str, parseList, callback) {\r\n        var result;\r\n        var returnNodes = [];\r\n        var parser = parserInput;\r\n        try {\r\n            parser.start(str, false, function fail(msg, index) {\r\n                callback({\r\n                    message: msg,\r\n                    index: index + currentIndex\r\n                });\r\n            });\r\n            for (var x = 0, p = void 0; (p = parseList[x]); x++) {\r\n                result = parsers[p]();\r\n                returnNodes.push(result || null);\r\n            }\r\n            var endInfo = parser.end();\r\n            if (endInfo.isFinished) {\r\n                callback(null, returnNodes);\r\n            }\r\n            else {\r\n                callback(true, null);\r\n            }\r\n        }\r\n        catch (e) {\r\n            throw new less_error_1.default({\r\n                index: e.index + currentIndex,\r\n                message: e.message\r\n            }, imports, fileInfo.filename);\r\n        }\r\n    }\r\n    //\r\n    // The Parser\r\n    //\r\n    return {\r\n        parserInput: parserInput,\r\n        imports: imports,\r\n        fileInfo: fileInfo,\r\n        parseNode: parseNode,\r\n        //\r\n        // Parse an input string into an abstract syntax tree,\r\n        // @param str A string containing 'less' markup\r\n        // @param callback call `callback` when done.\r\n        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply\r\n        //\r\n        parse: function (str, callback, additionalData) {\r\n            var root;\r\n            var err = null;\r\n            var globalVars;\r\n            var modifyVars;\r\n            var ignored;\r\n            var preText = '';\r\n            // Optionally disable @plugin parsing\r\n            if (additionalData && additionalData.disablePluginRule) {\r\n                parsers.plugin = function () {\r\n                    var dir = parserInput.$re(/^@plugin?\\s+/);\r\n                    if (dir) {\r\n                        error('@plugin statements are not allowed when disablePluginRule is set to true');\r\n                    }\r\n                };\r\n            }\r\n            globalVars = (additionalData && additionalData.globalVars) ? \"\".concat(Parser.serializeVars(additionalData.globalVars), \"\\n\") : '';\r\n            modifyVars = (additionalData && additionalData.modifyVars) ? \"\\n\".concat(Parser.serializeVars(additionalData.modifyVars)) : '';\r\n            if (context.pluginManager) {\r\n                var preProcessors = context.pluginManager.getPreProcessors();\r\n                for (var i = 0; i < preProcessors.length; i++) {\r\n                    str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });\r\n                }\r\n            }\r\n            if (globalVars || (additionalData && additionalData.banner)) {\r\n                preText = ((additionalData && additionalData.banner) ? additionalData.banner : '') + globalVars;\r\n                ignored = imports.contentsIgnoredChars;\r\n                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;\r\n                ignored[fileInfo.filename] += preText.length;\r\n            }\r\n            str = str.replace(/\\r\\n?/g, '\\n');\r\n            // Remove potential UTF Byte Order Mark\r\n            str = preText + str.replace(/^\\uFEFF/, '') + modifyVars;\r\n            imports.contents[fileInfo.filename] = str;\r\n            // Start with the primary rule.\r\n            // The whole syntax tree is held under a Ruleset node,\r\n            // with the `root` property set to true, so no `{}` are\r\n            // output. The callback is called when the input is parsed.\r\n            try {\r\n                parserInput.start(str, context.chunkInput, function fail(msg, index) {\r\n                    throw new less_error_1.default({\r\n                        index: index,\r\n                        type: 'Parse',\r\n                        message: msg,\r\n                        filename: fileInfo.filename\r\n                    }, imports);\r\n                });\r\n                tree_1.default.Node.prototype.parse = this;\r\n                root = new tree_1.default.Ruleset(null, this.parsers.primary());\r\n                tree_1.default.Node.prototype.rootNode = root;\r\n                root.root = true;\r\n                root.firstRoot = true;\r\n                root.functionRegistry = function_registry_1.default.inherit();\r\n            }\r\n            catch (e) {\r\n                return callback(new less_error_1.default(e, imports, fileInfo.filename));\r\n            }\r\n            // If `i` is smaller than the `input.length - 1`,\r\n            // it means the parser wasn't able to parse the whole\r\n            // string, so we've got a parsing error.\r\n            //\r\n            // We try to extract a \\n delimited string,\r\n            // showing the line where the parse error occurred.\r\n            // We split it up into two parts (the part which parsed,\r\n            // and the part which didn't), so we can color them differently.\r\n            var endInfo = parserInput.end();\r\n            if (!endInfo.isFinished) {\r\n                var message = endInfo.furthestPossibleErrorMessage;\r\n                if (!message) {\r\n                    message = 'Unrecognised input';\r\n                    if (endInfo.furthestChar === '}') {\r\n                        message += '. Possibly missing opening \\'{\\'';\r\n                    }\r\n                    else if (endInfo.furthestChar === ')') {\r\n                        message += '. Possibly missing opening \\'(\\'';\r\n                    }\r\n                    else if (endInfo.furthestReachedEnd) {\r\n                        message += '. Possibly missing something';\r\n                    }\r\n                }\r\n                err = new less_error_1.default({\r\n                    type: 'Parse',\r\n                    message: message,\r\n                    index: endInfo.furthest,\r\n                    filename: fileInfo.filename\r\n                }, imports);\r\n            }\r\n            var finish = function (e) {\r\n                e = err || e || imports.error;\r\n                if (e) {\r\n                    if (!(e instanceof less_error_1.default)) {\r\n                        e = new less_error_1.default(e, imports, fileInfo.filename);\r\n                    }\r\n                    return callback(e);\r\n                }\r\n                else {\r\n                    return callback(null, root);\r\n                }\r\n            };\r\n            if (context.processImports !== false) {\r\n                new visitors_1.default.ImportVisitor(imports, finish)\r\n                    .run(root);\r\n            }\r\n            else {\r\n                return finish();\r\n            }\r\n        },\r\n        //\r\n        // Here in, the parsing rules/functions\r\n        //\r\n        // The basic structure of the syntax tree generated is as follows:\r\n        //\r\n        //   Ruleset ->  Declaration -> Value -> Expression -> Entity\r\n        //\r\n        // Here's some Less code:\r\n        //\r\n        //    .class {\r\n        //      color: #fff;\r\n        //      border: 1px solid #000;\r\n        //      width: @w + 4px;\r\n        //      > .child {...}\r\n        //    }\r\n        //\r\n        // And here's what the parse tree might look like:\r\n        //\r\n        //     Ruleset (Selector '.class', [\r\n        //         Declaration (\"color\",  Value ([Expression [Color #fff]]))\r\n        //         Declaration (\"border\", Value ([Expression [Dimension 1px][Keyword \"solid\"][Color #000]]))\r\n        //         Declaration (\"width\",  Value ([Expression [Operation \" + \" [Variable \"@w\"][Dimension 4px]]]))\r\n        //         Ruleset (Selector [Element '>', '.child'], [...])\r\n        //     ])\r\n        //\r\n        //  In general, most rules will try to parse a token with the `$re()` function, and if the return\r\n        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\r\n        //  first, before parsing, that's when we use `peek()`.\r\n        //\r\n        parsers: parsers = {\r\n            //\r\n            // The `primary` rule is the *entry* and *exit* point of the parser.\r\n            // The rules here can appear at any level of the parse tree.\r\n            //\r\n            // The recursive nature of the grammar is an interplay between the `block`\r\n            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\r\n            // as represented by this simplified grammar:\r\n            //\r\n            //     primary  →  (ruleset | declaration)+\r\n            //     ruleset  →  selector+ block\r\n            //     block    →  '{' primary '}'\r\n            //\r\n            // Only at one point is the primary rule not called from the\r\n            // block rule: at the root level.\r\n            //\r\n            primary: function () {\r\n                var mixin = this.mixin;\r\n                var root = [];\r\n                var node;\r\n                while (true) {\r\n                    while (true) {\r\n                        node = this.comment();\r\n                        if (!node) {\r\n                            break;\r\n                        }\r\n                        root.push(node);\r\n                    }\r\n                    // always process comments before deciding if finished\r\n                    if (parserInput.finished) {\r\n                        break;\r\n                    }\r\n                    if (parserInput.peek('}')) {\r\n                        break;\r\n                    }\r\n                    node = this.extendRule();\r\n                    if (node) {\r\n                        root = root.concat(node);\r\n                        continue;\r\n                    }\r\n                    node = mixin.definition() || this.declaration() || mixin.call(false, false) ||\r\n                        this.ruleset() || this.variableCall() || this.entities.call() || this.atrule();\r\n                    if (node) {\r\n                        root.push(node);\r\n                    }\r\n                    else {\r\n                        var foundSemiColon = false;\r\n                        while (parserInput.$char(';')) {\r\n                            foundSemiColon = true;\r\n                        }\r\n                        if (!foundSemiColon) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return root;\r\n            },\r\n            // comments are collected by the main parsing mechanism and then assigned to nodes\r\n            // where the current structure allows it\r\n            comment: function () {\r\n                if (parserInput.commentStore.length) {\r\n                    var comment = parserInput.commentStore.shift();\r\n                    return new (tree_1.default.Comment)(comment.text, comment.isLineComment, comment.index + currentIndex, fileInfo);\r\n                }\r\n            },\r\n            //\r\n            // Entities are tokens which can be found inside an Expression\r\n            //\r\n            entities: {\r\n                mixinLookup: function () {\r\n                    return parsers.mixin.call(true, true);\r\n                },\r\n                //\r\n                // A string, which supports escaping \" and '\r\n                //\r\n                //     \"milky way\" 'he\\'s the one!'\r\n                //\r\n                quoted: function (forceEscaped) {\r\n                    var str;\r\n                    var index = parserInput.i;\r\n                    var isEscaped = false;\r\n                    parserInput.save();\r\n                    if (parserInput.$char('~')) {\r\n                        isEscaped = true;\r\n                    }\r\n                    else if (forceEscaped) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                    str = parserInput.$quoted();\r\n                    if (!str) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                    parserInput.forget();\r\n                    return new (tree_1.default.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index + currentIndex, fileInfo);\r\n                },\r\n                //\r\n                // A catch-all word, such as:\r\n                //\r\n                //     black border-collapse\r\n                //\r\n                keyword: function () {\r\n                    var k = parserInput.$char('%') || parserInput.$re(/^\\[?(?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\\]?/);\r\n                    if (k) {\r\n                        return tree_1.default.Color.fromKeyword(k) || new (tree_1.default.Keyword)(k);\r\n                    }\r\n                },\r\n                //\r\n                // A function call\r\n                //\r\n                //     rgb(255, 0, 255)\r\n                //\r\n                // The arguments are parsed with the `entities.arguments` parser.\r\n                //\r\n                call: function () {\r\n                    var name;\r\n                    var args;\r\n                    var func;\r\n                    var index = parserInput.i;\r\n                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\r\n                    if (parserInput.peek(/^url\\(/i)) {\r\n                        return;\r\n                    }\r\n                    parserInput.save();\r\n                    name = parserInput.$re(/^([\\w-]+|%|~|progid:[\\w.]+)\\(/);\r\n                    if (!name) {\r\n                        parserInput.forget();\r\n                        return;\r\n                    }\r\n                    name = name[1];\r\n                    func = this.customFuncCall(name);\r\n                    if (func) {\r\n                        args = func.parse();\r\n                        if (args && func.stop) {\r\n                            parserInput.forget();\r\n                            return args;\r\n                        }\r\n                    }\r\n                    args = this.arguments(args);\r\n                    if (!parserInput.$char(')')) {\r\n                        parserInput.restore('Could not parse call arguments or missing \\')\\'');\r\n                        return;\r\n                    }\r\n                    parserInput.forget();\r\n                    return new (tree_1.default.Call)(name, args, index + currentIndex, fileInfo);\r\n                },\r\n                declarationCall: function () {\r\n                    var validCall;\r\n                    var args;\r\n                    var index = parserInput.i;\r\n                    parserInput.save();\r\n                    validCall = parserInput.$re(/^[\\w]+\\(/);\r\n                    if (!validCall) {\r\n                        parserInput.forget();\r\n                        return;\r\n                    }\r\n                    validCall = validCall.substring(0, validCall.length - 1);\r\n                    var rule = this.ruleProperty();\r\n                    var value;\r\n                    if (rule) {\r\n                        value = this.value();\r\n                    }\r\n                    if (rule && value) {\r\n                        args = [new (tree_1.default.Declaration)(rule, value, null, null, parserInput.i + currentIndex, fileInfo, true)];\r\n                    }\r\n                    if (!parserInput.$char(')')) {\r\n                        parserInput.restore('Could not parse call arguments or missing \\')\\'');\r\n                        return;\r\n                    }\r\n                    parserInput.forget();\r\n                    return new (tree_1.default.Call)(validCall, args, index + currentIndex, fileInfo);\r\n                },\r\n                //\r\n                // Parsing rules for functions with non-standard args, e.g.:\r\n                //\r\n                //     boolean(not(2 > 1))\r\n                //\r\n                //     This is a quick prototype, to be modified/improved when\r\n                //     more custom-parsed funcs come (e.g. `selector(...)`)\r\n                //\r\n                customFuncCall: function (name) {\r\n                    /* Ideally the table is to be moved out of here for faster perf.,\r\n                       but it's quite tricky since it relies on all these `parsers`\r\n                       and `expect` available only here */\r\n                    return {\r\n                        alpha: f(parsers.ieAlpha, true),\r\n                        boolean: f(condition),\r\n                        'if': f(condition)\r\n                    }[name.toLowerCase()];\r\n                    function f(parse, stop) {\r\n                        return {\r\n                            parse: parse,\r\n                            stop: stop // when true - stop after parse() and return its result,\r\n                            // otherwise continue for plain args\r\n                        };\r\n                    }\r\n                    function condition() {\r\n                        return [expect(parsers.condition, 'expected condition')];\r\n                    }\r\n                },\r\n                arguments: function (prevArgs) {\r\n                    var argsComma = prevArgs || [];\r\n                    var argsSemiColon = [];\r\n                    var isSemiColonSeparated;\r\n                    var value;\r\n                    parserInput.save();\r\n                    while (true) {\r\n                        if (prevArgs) {\r\n                            prevArgs = false;\r\n                        }\r\n                        else {\r\n                            value = parsers.detachedRuleset() || this.assignment() || parsers.expression();\r\n                            if (!value) {\r\n                                break;\r\n                            }\r\n                            if (value.value && value.value.length == 1) {\r\n                                value = value.value[0];\r\n                            }\r\n                            argsComma.push(value);\r\n                        }\r\n                        if (parserInput.$char(',')) {\r\n                            continue;\r\n                        }\r\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\r\n                            isSemiColonSeparated = true;\r\n                            value = (argsComma.length < 1) ? argsComma[0]\r\n                                : new tree_1.default.Value(argsComma);\r\n                            argsSemiColon.push(value);\r\n                            argsComma = [];\r\n                        }\r\n                    }\r\n                    parserInput.forget();\r\n                    return isSemiColonSeparated ? argsSemiColon : argsComma;\r\n                },\r\n                literal: function () {\r\n                    return this.dimension() ||\r\n                        this.color() ||\r\n                        this.quoted() ||\r\n                        this.unicodeDescriptor();\r\n                },\r\n                // Assignments are argument entities for calls.\r\n                // They are present in ie filter properties as shown below.\r\n                //\r\n                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\r\n                //\r\n                assignment: function () {\r\n                    var key;\r\n                    var value;\r\n                    parserInput.save();\r\n                    key = parserInput.$re(/^\\w+(?=\\s?=)/i);\r\n                    if (!key) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                    if (!parserInput.$char('=')) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                    value = parsers.entity();\r\n                    if (value) {\r\n                        parserInput.forget();\r\n                        return new (tree_1.default.Assignment)(key, value);\r\n                    }\r\n                    else {\r\n                        parserInput.restore();\r\n                    }\r\n                },\r\n                //\r\n                // Parse url() tokens\r\n                //\r\n                // We use a specific rule for urls, because they don't really behave like\r\n                // standard function calls. The difference is that the argument doesn't have\r\n                // to be enclosed within a string, so it can't be parsed as an Expression.\r\n                //\r\n                url: function () {\r\n                    var value;\r\n                    var index = parserInput.i;\r\n                    parserInput.autoCommentAbsorb = false;\r\n                    if (!parserInput.$str('url(')) {\r\n                        parserInput.autoCommentAbsorb = true;\r\n                        return;\r\n                    }\r\n                    value = this.quoted() || this.variable() || this.property() ||\r\n                        parserInput.$re(/^(?:(?:\\\\[()'\"])|[^()'\"])+/) || '';\r\n                    parserInput.autoCommentAbsorb = true;\r\n                    expectChar(')');\r\n                    return new (tree_1.default.URL)((value.value !== undefined ||\r\n                        value instanceof tree_1.default.Variable ||\r\n                        value instanceof tree_1.default.Property) ?\r\n                        value : new (tree_1.default.Anonymous)(value, index), index + currentIndex, fileInfo);\r\n                },\r\n                //\r\n                // A Variable entity, such as `@fink`, in\r\n                //\r\n                //     width: @fink + 2px\r\n                //\r\n                // We use a different parser for variable definitions,\r\n                // see `parsers.variable`.\r\n                //\r\n                variable: function () {\r\n                    var ch;\r\n                    var name;\r\n                    var index = parserInput.i;\r\n                    parserInput.save();\r\n                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\\w-]+/))) {\r\n                        ch = parserInput.currentChar();\r\n                        if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\\s/)) {\r\n                            // this may be a VariableCall lookup\r\n                            var result = parsers.variableCall(name);\r\n                            if (result) {\r\n                                parserInput.forget();\r\n                                return result;\r\n                            }\r\n                        }\r\n                        parserInput.forget();\r\n                        return new (tree_1.default.Variable)(name, index + currentIndex, fileInfo);\r\n                    }\r\n                    parserInput.restore();\r\n                },\r\n                // A variable entity using the protective {} e.g. @{var}\r\n                variableCurly: function () {\r\n                    var curly;\r\n                    var index = parserInput.i;\r\n                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))) {\r\n                        return new (tree_1.default.Variable)(\"@\".concat(curly[1]), index + currentIndex, fileInfo);\r\n                    }\r\n                },\r\n                //\r\n                // A Property accessor, such as `$color`, in\r\n                //\r\n                //     background-color: $color\r\n                //\r\n                property: function () {\r\n                    var name;\r\n                    var index = parserInput.i;\r\n                    if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\\$[\\w-]+/))) {\r\n                        return new (tree_1.default.Property)(name, index + currentIndex, fileInfo);\r\n                    }\r\n                },\r\n                // A property entity useing the protective {} e.g. ${prop}\r\n                propertyCurly: function () {\r\n                    var curly;\r\n                    var index = parserInput.i;\r\n                    if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\\$\\{([\\w-]+)\\}/))) {\r\n                        return new (tree_1.default.Property)(\"$\".concat(curly[1]), index + currentIndex, fileInfo);\r\n                    }\r\n                },\r\n                //\r\n                // A Hexadecimal color\r\n                //\r\n                //     #4F3C2F\r\n                //\r\n                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\r\n                //\r\n                color: function () {\r\n                    var rgb;\r\n                    parserInput.save();\r\n                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\\w.#[])?/))) {\r\n                        if (!rgb[2]) {\r\n                            parserInput.forget();\r\n                            return new (tree_1.default.Color)(rgb[1], undefined, rgb[0]);\r\n                        }\r\n                    }\r\n                    parserInput.restore();\r\n                },\r\n                colorKeyword: function () {\r\n                    parserInput.save();\r\n                    var autoCommentAbsorb = parserInput.autoCommentAbsorb;\r\n                    parserInput.autoCommentAbsorb = false;\r\n                    var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);\r\n                    parserInput.autoCommentAbsorb = autoCommentAbsorb;\r\n                    if (!k) {\r\n                        parserInput.forget();\r\n                        return;\r\n                    }\r\n                    parserInput.restore();\r\n                    var color = tree_1.default.Color.fromKeyword(k);\r\n                    if (color) {\r\n                        parserInput.$str(k);\r\n                        return color;\r\n                    }\r\n                },\r\n                //\r\n                // A Dimension, that is, a number and a unit\r\n                //\r\n                //     0.5em 95%\r\n                //\r\n                dimension: function () {\r\n                    if (parserInput.peekNotNumeric()) {\r\n                        return;\r\n                    }\r\n                    var value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i);\r\n                    if (value) {\r\n                        return new (tree_1.default.Dimension)(value[1], value[2]);\r\n                    }\r\n                },\r\n                //\r\n                // A unicode descriptor, as is used in unicode-range\r\n                //\r\n                // U+0??  or U+00A1-00A9\r\n                //\r\n                unicodeDescriptor: function () {\r\n                    var ud;\r\n                    ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(-[0-9a-fA-F?]+)?/);\r\n                    if (ud) {\r\n                        return new (tree_1.default.UnicodeDescriptor)(ud[0]);\r\n                    }\r\n                },\r\n                //\r\n                // JavaScript code to be evaluated\r\n                //\r\n                //     `window.location.href`\r\n                //\r\n                javascript: function () {\r\n                    var js;\r\n                    var index = parserInput.i;\r\n                    parserInput.save();\r\n                    var escape = parserInput.$char('~');\r\n                    var jsQuote = parserInput.$char('`');\r\n                    if (!jsQuote) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                    js = parserInput.$re(/^[^`]*`/);\r\n                    if (js) {\r\n                        parserInput.forget();\r\n                        return new (tree_1.default.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index + currentIndex, fileInfo);\r\n                    }\r\n                    parserInput.restore('invalid javascript definition');\r\n                }\r\n            },\r\n            //\r\n            // The variable part of a variable definition. Used in the `rule` parser\r\n            //\r\n            //     @fink:\r\n            //\r\n            variable: function () {\r\n                var name;\r\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))) {\r\n                    return name[1];\r\n                }\r\n            },\r\n            //\r\n            // Call a variable value to retrieve a detached ruleset\r\n            // or a value from a detached ruleset's rules.\r\n            //\r\n            //     @fink();\r\n            //     @fink;\r\n            //     color: @fink[@color];\r\n            //\r\n            variableCall: function (parsedName) {\r\n                var lookups;\r\n                var i = parserInput.i;\r\n                var inValue = !!parsedName;\r\n                var name = parsedName;\r\n                parserInput.save();\r\n                if (name || (parserInput.currentChar() === '@'\r\n                    && (name = parserInput.$re(/^(@[\\w-]+)(\\(\\s*\\))?/)))) {\r\n                    lookups = this.mixin.ruleLookups();\r\n                    if (!lookups && ((inValue && parserInput.$str('()') !== '()') || (name[2] !== '()'))) {\r\n                        parserInput.restore('Missing \\'[...]\\' lookup in variable call');\r\n                        return;\r\n                    }\r\n                    if (!inValue) {\r\n                        name = name[1];\r\n                    }\r\n                    var call = new tree_1.default.VariableCall(name, i, fileInfo);\r\n                    if (!inValue && parsers.end()) {\r\n                        parserInput.forget();\r\n                        return call;\r\n                    }\r\n                    else {\r\n                        parserInput.forget();\r\n                        return new tree_1.default.NamespaceValue(call, lookups, i, fileInfo);\r\n                    }\r\n                }\r\n                parserInput.restore();\r\n            },\r\n            //\r\n            // extend syntax - used to extend selectors\r\n            //\r\n            extend: function (isRule) {\r\n                var elements;\r\n                var e;\r\n                var index = parserInput.i;\r\n                var option;\r\n                var extendList;\r\n                var extend;\r\n                if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {\r\n                    return;\r\n                }\r\n                do {\r\n                    option = null;\r\n                    elements = null;\r\n                    while (!(option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\r\n                        e = this.element();\r\n                        if (!e) {\r\n                            break;\r\n                        }\r\n                        if (elements) {\r\n                            elements.push(e);\r\n                        }\r\n                        else {\r\n                            elements = [e];\r\n                        }\r\n                    }\r\n                    option = option && option[1];\r\n                    if (!elements) {\r\n                        error('Missing target selector for :extend().');\r\n                    }\r\n                    extend = new (tree_1.default.Extend)(new (tree_1.default.Selector)(elements), option, index + currentIndex, fileInfo);\r\n                    if (extendList) {\r\n                        extendList.push(extend);\r\n                    }\r\n                    else {\r\n                        extendList = [extend];\r\n                    }\r\n                } while (parserInput.$char(','));\r\n                expect(/^\\)/);\r\n                if (isRule) {\r\n                    expect(/^;/);\r\n                }\r\n                return extendList;\r\n            },\r\n            //\r\n            // extendRule - used in a rule to extend all the parent selectors\r\n            //\r\n            extendRule: function () {\r\n                return this.extend(true);\r\n            },\r\n            //\r\n            // Mixins\r\n            //\r\n            mixin: {\r\n                //\r\n                // A Mixin call, with an optional argument list\r\n                //\r\n                //     #mixins > .square(#fff);\r\n                //     #mixins.square(#fff);\r\n                //     .rounded(4px, black);\r\n                //     .button;\r\n                //\r\n                // We can lookup / return a value using the lookup syntax:\r\n                //\r\n                //     color: #mixin.square(#fff)[@color];\r\n                //\r\n                // The `while` loop is there because mixins can be\r\n                // namespaced, but we only support the child and descendant\r\n                // selector for now.\r\n                //\r\n                call: function (inValue, getLookup) {\r\n                    var s = parserInput.currentChar();\r\n                    var important = false;\r\n                    var lookups;\r\n                    var index = parserInput.i;\r\n                    var elements;\r\n                    var args;\r\n                    var hasParens;\r\n                    if (s !== '.' && s !== '#') {\r\n                        return;\r\n                    }\r\n                    parserInput.save(); // stop us absorbing part of an invalid selector\r\n                    elements = this.elements();\r\n                    if (elements) {\r\n                        if (parserInput.$char('(')) {\r\n                            args = this.args(true).args;\r\n                            expectChar(')');\r\n                            hasParens = true;\r\n                        }\r\n                        if (getLookup !== false) {\r\n                            lookups = this.ruleLookups();\r\n                        }\r\n                        if (getLookup === true && !lookups) {\r\n                            parserInput.restore();\r\n                            return;\r\n                        }\r\n                        if (inValue && !lookups && !hasParens) {\r\n                            // This isn't a valid in-value mixin call\r\n                            parserInput.restore();\r\n                            return;\r\n                        }\r\n                        if (!inValue && parsers.important()) {\r\n                            important = true;\r\n                        }\r\n                        if (inValue || parsers.end()) {\r\n                            parserInput.forget();\r\n                            var mixin = new (tree_1.default.mixin.Call)(elements, args, index + currentIndex, fileInfo, !lookups && important);\r\n                            if (lookups) {\r\n                                return new tree_1.default.NamespaceValue(mixin, lookups);\r\n                            }\r\n                            else {\r\n                                return mixin;\r\n                            }\r\n                        }\r\n                    }\r\n                    parserInput.restore();\r\n                },\r\n                /**\r\n                 * Matching elements for mixins\r\n                 * (Start with . or # and can have > )\r\n                 */\r\n                elements: function () {\r\n                    var elements;\r\n                    var e;\r\n                    var c;\r\n                    var elem;\r\n                    var elemIndex;\r\n                    var re = /^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;\r\n                    while (true) {\r\n                        elemIndex = parserInput.i;\r\n                        e = parserInput.$re(re);\r\n                        if (!e) {\r\n                            break;\r\n                        }\r\n                        elem = new (tree_1.default.Element)(c, e, false, elemIndex + currentIndex, fileInfo);\r\n                        if (elements) {\r\n                            elements.push(elem);\r\n                        }\r\n                        else {\r\n                            elements = [elem];\r\n                        }\r\n                        c = parserInput.$char('>');\r\n                    }\r\n                    return elements;\r\n                },\r\n                args: function (isCall) {\r\n                    var entities = parsers.entities;\r\n                    var returner = { args: null, variadic: false };\r\n                    var expressions = [];\r\n                    var argsSemiColon = [];\r\n                    var argsComma = [];\r\n                    var isSemiColonSeparated;\r\n                    var expressionContainsNamed;\r\n                    var name;\r\n                    var nameLoop;\r\n                    var value;\r\n                    var arg;\r\n                    var expand;\r\n                    var hasSep = true;\r\n                    parserInput.save();\r\n                    while (true) {\r\n                        if (isCall) {\r\n                            arg = parsers.detachedRuleset() || parsers.expression();\r\n                        }\r\n                        else {\r\n                            parserInput.commentStore.length = 0;\r\n                            if (parserInput.$str('...')) {\r\n                                returner.variadic = true;\r\n                                if (parserInput.$char(';') && !isSemiColonSeparated) {\r\n                                    isSemiColonSeparated = true;\r\n                                }\r\n                                (isSemiColonSeparated ? argsSemiColon : argsComma)\r\n                                    .push({ variadic: true });\r\n                                break;\r\n                            }\r\n                            arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);\r\n                        }\r\n                        if (!arg || !hasSep) {\r\n                            break;\r\n                        }\r\n                        nameLoop = null;\r\n                        if (arg.throwAwayComments) {\r\n                            arg.throwAwayComments();\r\n                        }\r\n                        value = arg;\r\n                        var val = null;\r\n                        if (isCall) {\r\n                            // Variable\r\n                            if (arg.value && arg.value.length == 1) {\r\n                                val = arg.value[0];\r\n                            }\r\n                        }\r\n                        else {\r\n                            val = arg;\r\n                        }\r\n                        if (val && (val instanceof tree_1.default.Variable || val instanceof tree_1.default.Property)) {\r\n                            if (parserInput.$char(':')) {\r\n                                if (expressions.length > 0) {\r\n                                    if (isSemiColonSeparated) {\r\n                                        error('Cannot mix ; and , as delimiter types');\r\n                                    }\r\n                                    expressionContainsNamed = true;\r\n                                }\r\n                                value = parsers.detachedRuleset() || parsers.expression();\r\n                                if (!value) {\r\n                                    if (isCall) {\r\n                                        error('could not understand value for named argument');\r\n                                    }\r\n                                    else {\r\n                                        parserInput.restore();\r\n                                        returner.args = [];\r\n                                        return returner;\r\n                                    }\r\n                                }\r\n                                nameLoop = (name = val.name);\r\n                            }\r\n                            else if (parserInput.$str('...')) {\r\n                                if (!isCall) {\r\n                                    returner.variadic = true;\r\n                                    if (parserInput.$char(';') && !isSemiColonSeparated) {\r\n                                        isSemiColonSeparated = true;\r\n                                    }\r\n                                    (isSemiColonSeparated ? argsSemiColon : argsComma)\r\n                                        .push({ name: arg.name, variadic: true });\r\n                                    break;\r\n                                }\r\n                                else {\r\n                                    expand = true;\r\n                                }\r\n                            }\r\n                            else if (!isCall) {\r\n                                name = nameLoop = val.name;\r\n                                value = null;\r\n                            }\r\n                        }\r\n                        if (value) {\r\n                            expressions.push(value);\r\n                        }\r\n                        argsComma.push({ name: nameLoop, value: value, expand: expand });\r\n                        if (parserInput.$char(',')) {\r\n                            hasSep = true;\r\n                            continue;\r\n                        }\r\n                        hasSep = parserInput.$char(';') === ';';\r\n                        if (hasSep || isSemiColonSeparated) {\r\n                            if (expressionContainsNamed) {\r\n                                error('Cannot mix ; and , as delimiter types');\r\n                            }\r\n                            isSemiColonSeparated = true;\r\n                            if (expressions.length > 1) {\r\n                                value = new (tree_1.default.Value)(expressions);\r\n                            }\r\n                            argsSemiColon.push({ name: name, value: value, expand: expand });\r\n                            name = null;\r\n                            expressions = [];\r\n                            expressionContainsNamed = false;\r\n                        }\r\n                    }\r\n                    parserInput.forget();\r\n                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;\r\n                    return returner;\r\n                },\r\n                //\r\n                // A Mixin definition, with a list of parameters\r\n                //\r\n                //     .rounded (@radius: 2px, @color) {\r\n                //        ...\r\n                //     }\r\n                //\r\n                // Until we have a finer grained state-machine, we have to\r\n                // do a look-ahead, to make sure we don't have a mixin call.\r\n                // See the `rule` function for more information.\r\n                //\r\n                // We start by matching `.rounded (`, and then proceed on to\r\n                // the argument list, which has optional default values.\r\n                // We store the parameters in `params`, with a `value` key,\r\n                // if there is a value, such as in the case of `@radius`.\r\n                //\r\n                // Once we've got our params list, and a closing `)`, we parse\r\n                // the `{...}` block.\r\n                //\r\n                definition: function () {\r\n                    var name;\r\n                    var params = [];\r\n                    var match;\r\n                    var ruleset;\r\n                    var cond;\r\n                    var variadic = false;\r\n                    if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||\r\n                        parserInput.peek(/^[^{]*\\}/)) {\r\n                        return;\r\n                    }\r\n                    parserInput.save();\r\n                    match = parserInput.$re(/^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/);\r\n                    if (match) {\r\n                        name = match[1];\r\n                        var argInfo = this.args(false);\r\n                        params = argInfo.args;\r\n                        variadic = argInfo.variadic;\r\n                        // .mixincall(\"@{a}\");\r\n                        // looks a bit like a mixin definition..\r\n                        // also\r\n                        // .mixincall(@a: {rule: set;});\r\n                        // so we have to be nice and restore\r\n                        if (!parserInput.$char(')')) {\r\n                            parserInput.restore('Missing closing \\')\\'');\r\n                            return;\r\n                        }\r\n                        parserInput.commentStore.length = 0;\r\n                        if (parserInput.$str('when')) { // Guard\r\n                            cond = expect(parsers.conditions, 'expected condition');\r\n                        }\r\n                        ruleset = parsers.block();\r\n                        if (ruleset) {\r\n                            parserInput.forget();\r\n                            return new (tree_1.default.mixin.Definition)(name, params, ruleset, cond, variadic);\r\n                        }\r\n                        else {\r\n                            parserInput.restore();\r\n                        }\r\n                    }\r\n                    else {\r\n                        parserInput.restore();\r\n                    }\r\n                },\r\n                ruleLookups: function () {\r\n                    var rule;\r\n                    var lookups = [];\r\n                    if (parserInput.currentChar() !== '[') {\r\n                        return;\r\n                    }\r\n                    while (true) {\r\n                        parserInput.save();\r\n                        rule = this.lookupValue();\r\n                        if (!rule && rule !== '') {\r\n                            parserInput.restore();\r\n                            break;\r\n                        }\r\n                        lookups.push(rule);\r\n                        parserInput.forget();\r\n                    }\r\n                    if (lookups.length > 0) {\r\n                        return lookups;\r\n                    }\r\n                },\r\n                lookupValue: function () {\r\n                    parserInput.save();\r\n                    if (!parserInput.$char('[')) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                    var name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);\r\n                    if (!parserInput.$char(']')) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                    if (name || name === '') {\r\n                        parserInput.forget();\r\n                        return name;\r\n                    }\r\n                    parserInput.restore();\r\n                }\r\n            },\r\n            //\r\n            // Entities are the smallest recognized token,\r\n            // and can be found inside a rule's value.\r\n            //\r\n            entity: function () {\r\n                var entities = this.entities;\r\n                return this.comment() || entities.literal() || entities.variable() || entities.url() ||\r\n                    entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||\r\n                    entities.javascript();\r\n            },\r\n            //\r\n            // A Declaration terminator. Note that we use `peek()` to check for '}',\r\n            // because the `block` rule will be expecting it, but we still need to make sure\r\n            // it's there, if ';' was omitted.\r\n            //\r\n            end: function () {\r\n                return parserInput.$char(';') || parserInput.peek('}');\r\n            },\r\n            //\r\n            // IE's alpha function\r\n            //\r\n            //     alpha(opacity=88)\r\n            //\r\n            ieAlpha: function () {\r\n                var value;\r\n                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\r\n                if (!parserInput.$re(/^opacity=/i)) {\r\n                    return;\r\n                }\r\n                value = parserInput.$re(/^\\d+/);\r\n                if (!value) {\r\n                    value = expect(parsers.entities.variable, 'Could not parse alpha');\r\n                    value = \"@{\".concat(value.name.slice(1), \"}\");\r\n                }\r\n                expectChar(')');\r\n                return new tree_1.default.Quoted('', \"alpha(opacity=\".concat(value, \")\"));\r\n            },\r\n            //\r\n            // A Selector Element\r\n            //\r\n            //     div\r\n            //     + h1\r\n            //     #socks\r\n            //     input[type=\"text\"]\r\n            //\r\n            // Elements are the building blocks for Selectors,\r\n            // they are made out of a `Combinator` (see combinator rule),\r\n            // and an element name, such as a tag a class, or `*`.\r\n            //\r\n            element: function () {\r\n                var e;\r\n                var c;\r\n                var v;\r\n                var index = parserInput.i;\r\n                c = this.combinator();\r\n                e = parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) ||\r\n                    // eslint-disable-next-line no-control-regex\r\n                    parserInput.$re(/^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||\r\n                    parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||\r\n                    parserInput.$re(/^\\([^&()@]+\\)/) || parserInput.$re(/^[.#:](?=@)/) ||\r\n                    this.entities.variableCurly();\r\n                if (!e) {\r\n                    parserInput.save();\r\n                    if (parserInput.$char('(')) {\r\n                        if ((v = this.selector(false)) && parserInput.$char(')')) {\r\n                            e = new (tree_1.default.Paren)(v);\r\n                            parserInput.forget();\r\n                        }\r\n                        else {\r\n                            parserInput.restore('Missing closing \\')\\'');\r\n                        }\r\n                    }\r\n                    else {\r\n                        parserInput.forget();\r\n                    }\r\n                }\r\n                if (e) {\r\n                    return new (tree_1.default.Element)(c, e, e instanceof tree_1.default.Variable, index + currentIndex, fileInfo);\r\n                }\r\n            },\r\n            //\r\n            // Combinators combine elements together, in a Selector.\r\n            //\r\n            // Because our parser isn't white-space sensitive, special care\r\n            // has to be taken, when parsing the descendant combinator, ` `,\r\n            // as it's an empty space. We have to check the previous character\r\n            // in the input, to see if it's a ` ` character. More info on how\r\n            // we deal with this in *combinator.js*.\r\n            //\r\n            combinator: function () {\r\n                var c = parserInput.currentChar();\r\n                if (c === '/') {\r\n                    parserInput.save();\r\n                    var slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i);\r\n                    if (slashedCombinator) {\r\n                        parserInput.forget();\r\n                        return new (tree_1.default.Combinator)(slashedCombinator);\r\n                    }\r\n                    parserInput.restore();\r\n                }\r\n                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\r\n                    parserInput.i++;\r\n                    if (c === '^' && parserInput.currentChar() === '^') {\r\n                        c = '^^';\r\n                        parserInput.i++;\r\n                    }\r\n                    while (parserInput.isWhitespace()) {\r\n                        parserInput.i++;\r\n                    }\r\n                    return new (tree_1.default.Combinator)(c);\r\n                }\r\n                else if (parserInput.isWhitespace(-1)) {\r\n                    return new (tree_1.default.Combinator)(' ');\r\n                }\r\n                else {\r\n                    return new (tree_1.default.Combinator)(null);\r\n                }\r\n            },\r\n            //\r\n            // A CSS Selector\r\n            // with less extensions e.g. the ability to extend and guard\r\n            //\r\n            //     .class > div + h1\r\n            //     li a:hover\r\n            //\r\n            // Selectors are made out of one or more Elements, see above.\r\n            //\r\n            selector: function (isLess) {\r\n                var index = parserInput.i;\r\n                var elements;\r\n                var extendList;\r\n                var c;\r\n                var e;\r\n                var allExtends;\r\n                var when;\r\n                var condition;\r\n                isLess = isLess !== false;\r\n                while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str('when'))) || (e = this.element())) {\r\n                    if (when) {\r\n                        condition = expect(this.conditions, 'expected condition');\r\n                    }\r\n                    else if (condition) {\r\n                        error('CSS guard can only be used at the end of selector');\r\n                    }\r\n                    else if (extendList) {\r\n                        if (allExtends) {\r\n                            allExtends = allExtends.concat(extendList);\r\n                        }\r\n                        else {\r\n                            allExtends = extendList;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (allExtends) {\r\n                            error('Extend can only be used at the end of selector');\r\n                        }\r\n                        c = parserInput.currentChar();\r\n                        if (elements) {\r\n                            elements.push(e);\r\n                        }\r\n                        else {\r\n                            elements = [e];\r\n                        }\r\n                        e = null;\r\n                    }\r\n                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\r\n                        break;\r\n                    }\r\n                }\r\n                if (elements) {\r\n                    return new (tree_1.default.Selector)(elements, allExtends, condition, index + currentIndex, fileInfo);\r\n                }\r\n                if (allExtends) {\r\n                    error('Extend must be used to extend a selector, it cannot be used on its own');\r\n                }\r\n            },\r\n            selectors: function () {\r\n                var s;\r\n                var selectors;\r\n                while (true) {\r\n                    s = this.selector();\r\n                    if (!s) {\r\n                        break;\r\n                    }\r\n                    if (selectors) {\r\n                        selectors.push(s);\r\n                    }\r\n                    else {\r\n                        selectors = [s];\r\n                    }\r\n                    parserInput.commentStore.length = 0;\r\n                    if (s.condition && selectors.length > 1) {\r\n                        error('Guards are only currently allowed on a single selector.');\r\n                    }\r\n                    if (!parserInput.$char(',')) {\r\n                        break;\r\n                    }\r\n                    if (s.condition) {\r\n                        error('Guards are only currently allowed on a single selector.');\r\n                    }\r\n                    parserInput.commentStore.length = 0;\r\n                }\r\n                return selectors;\r\n            },\r\n            attribute: function () {\r\n                if (!parserInput.$char('[')) {\r\n                    return;\r\n                }\r\n                var entities = this.entities;\r\n                var key;\r\n                var val;\r\n                var op;\r\n                //\r\n                // case-insensitive flag\r\n                // e.g. [attr operator value i]\r\n                //\r\n                var cif;\r\n                var keys;\r\n                while ((key = entities.variableCurly()) || (key = parserInput.$re(/^(?:[_A-Za-z0-9-*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/))) {\r\n                    if (keys) {\r\n                        keys.push(key);\r\n                    }\r\n                    else {\r\n                        keys = [key];\r\n                    }\r\n                    key = null;\r\n                }\r\n                if (keys.length == 0) {\r\n                    error('unexpected token');\r\n                }\r\n                op = parserInput.$re(/^[|~*$^]?=/);\r\n                if (op) {\r\n                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\\w-]+/) || entities.variableCurly();\r\n                    if (val) {\r\n                        cif = parserInput.$re(/^[iIsS]/);\r\n                    }\r\n                }\r\n                expectChar(']');\r\n                return new (tree_1.default.Attribute)(keys, op, val, cif);\r\n            },\r\n            //\r\n            // The `block` rule is used by `ruleset` and `mixin.definition`.\r\n            // It's a wrapper around the `primary` rule, with added `{}`.\r\n            //\r\n            block: function () {\r\n                var content;\r\n                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {\r\n                    return content;\r\n                }\r\n            },\r\n            blockRuleset: function () {\r\n                var block = this.block();\r\n                if (block) {\r\n                    block = new tree_1.default.Ruleset(null, block);\r\n                }\r\n                return block;\r\n            },\r\n            detachedRuleset: function () {\r\n                var argInfo;\r\n                var params;\r\n                var variadic;\r\n                parserInput.save();\r\n                if (parserInput.$re(/^[.#]\\(/)) {\r\n                    /**\r\n                     * DR args currently only implemented for each() function, and not\r\n                     * yet settable as `@dr: #(@arg) {}`\r\n                     * This should be done when DRs are merged with mixins.\r\n                     * See: https://github.com/less/less-meta/issues/16\r\n                     */\r\n                    argInfo = this.mixin.args(false);\r\n                    params = argInfo.args;\r\n                    variadic = argInfo.variadic;\r\n                    if (!parserInput.$char(')')) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                }\r\n                var blockRuleset = this.blockRuleset();\r\n                if (blockRuleset) {\r\n                    parserInput.forget();\r\n                    if (params) {\r\n                        return new tree_1.default.mixin.Definition(null, params, blockRuleset, null, variadic);\r\n                    }\r\n                    return new tree_1.default.DetachedRuleset(blockRuleset);\r\n                }\r\n                parserInput.restore();\r\n            },\r\n            //\r\n            // div, .class, body > p {...}\r\n            //\r\n            ruleset: function () {\r\n                var selectors;\r\n                var rules;\r\n                var debugInfo;\r\n                parserInput.save();\r\n                if (context.dumpLineNumbers) {\r\n                    debugInfo = getDebugInfo(parserInput.i);\r\n                }\r\n                selectors = this.selectors();\r\n                if (selectors && (rules = this.block())) {\r\n                    parserInput.forget();\r\n                    var ruleset = new (tree_1.default.Ruleset)(selectors, rules, context.strictImports);\r\n                    if (context.dumpLineNumbers) {\r\n                        ruleset.debugInfo = debugInfo;\r\n                    }\r\n                    return ruleset;\r\n                }\r\n                else {\r\n                    parserInput.restore();\r\n                }\r\n            },\r\n            declaration: function () {\r\n                var name;\r\n                var value;\r\n                var index = parserInput.i;\r\n                var hasDR;\r\n                var c = parserInput.currentChar();\r\n                var important;\r\n                var merge;\r\n                var isVariable;\r\n                if (c === '.' || c === '#' || c === '&' || c === ':') {\r\n                    return;\r\n                }\r\n                parserInput.save();\r\n                name = this.variable() || this.ruleProperty();\r\n                if (name) {\r\n                    isVariable = typeof name === 'string';\r\n                    if (isVariable) {\r\n                        value = this.detachedRuleset();\r\n                        if (value) {\r\n                            hasDR = true;\r\n                        }\r\n                    }\r\n                    parserInput.commentStore.length = 0;\r\n                    if (!value) {\r\n                        // a name returned by this.ruleProperty() is always an array of the form:\r\n                        // [string-1, ..., string-n, \"\"] or [string-1, ..., string-n, \"+\"]\r\n                        // where each item is a tree.Keyword or tree.Variable\r\n                        merge = !isVariable && name.length > 1 && name.pop().value;\r\n                        // Custom property values get permissive parsing\r\n                        if (name[0].value && name[0].value.slice(0, 2) === '--') {\r\n                            value = this.permissiveValue(/[;}]/);\r\n                        }\r\n                        // Try to store values as anonymous\r\n                        // If we need the value later we'll re-parse it in ruleset.parseValue\r\n                        else {\r\n                            value = this.anonymousValue();\r\n                        }\r\n                        if (value) {\r\n                            parserInput.forget();\r\n                            // anonymous values absorb the end ';' which is required for them to work\r\n                            return new (tree_1.default.Declaration)(name, value, false, merge, index + currentIndex, fileInfo);\r\n                        }\r\n                        if (!value) {\r\n                            value = this.value();\r\n                        }\r\n                        if (value) {\r\n                            important = this.important();\r\n                        }\r\n                        else if (isVariable) {\r\n                            // As a last resort, try permissiveValue\r\n                            value = this.permissiveValue();\r\n                        }\r\n                    }\r\n                    if (value && (this.end() || hasDR)) {\r\n                        parserInput.forget();\r\n                        return new (tree_1.default.Declaration)(name, value, important, merge, index + currentIndex, fileInfo);\r\n                    }\r\n                    else {\r\n                        parserInput.restore();\r\n                    }\r\n                }\r\n                else {\r\n                    parserInput.restore();\r\n                }\r\n            },\r\n            anonymousValue: function () {\r\n                var index = parserInput.i;\r\n                var match = parserInput.$re(/^([^.#@$+/'\"*`(;{}-]*);/);\r\n                if (match) {\r\n                    return new (tree_1.default.Anonymous)(match[1], index + currentIndex);\r\n                }\r\n            },\r\n            /**\r\n             * Used for custom properties, at-rules, and variables (as fallback)\r\n             * Parses almost anything inside of {} [] () \"\" blocks\r\n             * until it reaches outer-most tokens.\r\n             *\r\n             * First, it will try to parse comments and entities to reach\r\n             * the end. This is mostly like the Expression parser except no\r\n             * math is allowed.\r\n             */\r\n            permissiveValue: function (untilTokens) {\r\n                var i;\r\n                var e;\r\n                var done;\r\n                var value;\r\n                var tok = untilTokens || ';';\r\n                var index = parserInput.i;\r\n                var result = [];\r\n                function testCurrentChar() {\r\n                    var char = parserInput.currentChar();\r\n                    if (typeof tok === 'string') {\r\n                        return char === tok;\r\n                    }\r\n                    else {\r\n                        return tok.test(char);\r\n                    }\r\n                }\r\n                if (testCurrentChar()) {\r\n                    return;\r\n                }\r\n                value = [];\r\n                do {\r\n                    e = this.comment();\r\n                    if (e) {\r\n                        value.push(e);\r\n                        continue;\r\n                    }\r\n                    e = this.entity();\r\n                    if (e) {\r\n                        value.push(e);\r\n                    }\r\n                    if (parserInput.peek(',')) {\r\n                        value.push(new (tree_1.default.Anonymous)(',', parserInput.i));\r\n                        parserInput.$char(',');\r\n                    }\r\n                } while (e);\r\n                done = testCurrentChar();\r\n                if (value.length > 0) {\r\n                    value = new (tree_1.default.Expression)(value);\r\n                    if (done) {\r\n                        return value;\r\n                    }\r\n                    else {\r\n                        result.push(value);\r\n                    }\r\n                    // Preserve space before $parseUntil as it will not\r\n                    if (parserInput.prevChar() === ' ') {\r\n                        result.push(new tree_1.default.Anonymous(' ', index));\r\n                    }\r\n                }\r\n                parserInput.save();\r\n                value = parserInput.$parseUntil(tok);\r\n                if (value) {\r\n                    if (typeof value === 'string') {\r\n                        error(\"Expected '\".concat(value, \"'\"), 'Parse');\r\n                    }\r\n                    if (value.length === 1 && value[0] === ' ') {\r\n                        parserInput.forget();\r\n                        return new tree_1.default.Anonymous('', index);\r\n                    }\r\n                    var item = void 0;\r\n                    for (i = 0; i < value.length; i++) {\r\n                        item = value[i];\r\n                        if (Array.isArray(item)) {\r\n                            // Treat actual quotes as normal quoted values\r\n                            result.push(new tree_1.default.Quoted(item[0], item[1], true, index, fileInfo));\r\n                        }\r\n                        else {\r\n                            if (i === value.length - 1) {\r\n                                item = item.trim();\r\n                            }\r\n                            // Treat like quoted values, but replace vars like unquoted expressions\r\n                            var quote = new tree_1.default.Quoted('\\'', item, true, index, fileInfo);\r\n                            quote.variableRegex = /@([\\w-]+)/g;\r\n                            quote.propRegex = /\\$([\\w-]+)/g;\r\n                            result.push(quote);\r\n                        }\r\n                    }\r\n                    parserInput.forget();\r\n                    return new tree_1.default.Expression(result, true);\r\n                }\r\n                parserInput.restore();\r\n            },\r\n            //\r\n            // An @import atrule\r\n            //\r\n            //     @import \"lib\";\r\n            //\r\n            // Depending on our environment, importing is done differently:\r\n            // In the browser, it's an XHR request, in Node, it would be a\r\n            // file-system operation. The function used for importing is\r\n            // stored in `import`, which we pass to the Import constructor.\r\n            //\r\n            'import': function () {\r\n                var path;\r\n                var features;\r\n                var index = parserInput.i;\r\n                var dir = parserInput.$re(/^@import\\s+/);\r\n                if (dir) {\r\n                    var options = (dir ? this.importOptions() : null) || {};\r\n                    if ((path = this.entities.quoted() || this.entities.url())) {\r\n                        features = this.mediaFeatures({});\r\n                        if (!parserInput.$char(';')) {\r\n                            parserInput.i = index;\r\n                            error('missing semi-colon or unrecognised media features on import');\r\n                        }\r\n                        features = features && new (tree_1.default.Value)(features);\r\n                        return new (tree_1.default.Import)(path, features, options, index + currentIndex, fileInfo);\r\n                    }\r\n                    else {\r\n                        parserInput.i = index;\r\n                        error('malformed import statement');\r\n                    }\r\n                }\r\n            },\r\n            importOptions: function () {\r\n                var o;\r\n                var options = {};\r\n                var optionName;\r\n                var value;\r\n                // list of options, surrounded by parens\r\n                if (!parserInput.$char('(')) {\r\n                    return null;\r\n                }\r\n                do {\r\n                    o = this.importOption();\r\n                    if (o) {\r\n                        optionName = o;\r\n                        value = true;\r\n                        switch (optionName) {\r\n                            case 'css':\r\n                                optionName = 'less';\r\n                                value = false;\r\n                                break;\r\n                            case 'once':\r\n                                optionName = 'multiple';\r\n                                value = false;\r\n                                break;\r\n                        }\r\n                        options[optionName] = value;\r\n                        if (!parserInput.$char(',')) {\r\n                            break;\r\n                        }\r\n                    }\r\n                } while (o);\r\n                expectChar(')');\r\n                return options;\r\n            },\r\n            importOption: function () {\r\n                var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);\r\n                if (opt) {\r\n                    return opt[1];\r\n                }\r\n            },\r\n            mediaFeature: function (syntaxOptions) {\r\n                var entities = this.entities;\r\n                var nodes = [];\r\n                var e;\r\n                var p;\r\n                var rangeP;\r\n                parserInput.save();\r\n                do {\r\n                    e = entities.declarationCall.bind(this)() || entities.keyword() || entities.variable() || entities.mixinLookup();\r\n                    if (e) {\r\n                        nodes.push(e);\r\n                    }\r\n                    else if (parserInput.$char('(')) {\r\n                        p = this.property();\r\n                        parserInput.save();\r\n                        if (!p && syntaxOptions.queryInParens && parserInput.$re(/^[0-9a-z-]*\\s*([<>]=|<=|>=|[<>]|=)/)) {\r\n                            parserInput.restore();\r\n                            p = this.condition();\r\n                            parserInput.save();\r\n                            rangeP = this.atomicCondition(null, p.rvalue);\r\n                            if (!rangeP) {\r\n                                parserInput.restore();\r\n                            }\r\n                        }\r\n                        else {\r\n                            parserInput.restore();\r\n                            e = this.value();\r\n                        }\r\n                        if (parserInput.$char(')')) {\r\n                            if (p && !e) {\r\n                                nodes.push(new (tree_1.default.Paren)(new (tree_1.default.QueryInParens)(p.op, p.lvalue, p.rvalue, rangeP ? rangeP.op : null, rangeP ? rangeP.rvalue : null, p._index)));\r\n                                e = p;\r\n                            }\r\n                            else if (p && e) {\r\n                                nodes.push(new (tree_1.default.Paren)(new (tree_1.default.Declaration)(p, e, null, null, parserInput.i + currentIndex, fileInfo, true)));\r\n                            }\r\n                            else if (e) {\r\n                                nodes.push(new (tree_1.default.Paren)(e));\r\n                            }\r\n                            else {\r\n                                error('badly formed media feature definition');\r\n                            }\r\n                        }\r\n                        else {\r\n                            error('Missing closing \\')\\'', 'Parse');\r\n                        }\r\n                    }\r\n                } while (e);\r\n                parserInput.forget();\r\n                if (nodes.length > 0) {\r\n                    return new (tree_1.default.Expression)(nodes);\r\n                }\r\n            },\r\n            mediaFeatures: function (syntaxOptions) {\r\n                var entities = this.entities;\r\n                var features = [];\r\n                var e;\r\n                do {\r\n                    e = this.mediaFeature(syntaxOptions);\r\n                    if (e) {\r\n                        features.push(e);\r\n                        if (!parserInput.$char(',')) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        e = entities.variable() || entities.mixinLookup();\r\n                        if (e) {\r\n                            features.push(e);\r\n                            if (!parserInput.$char(',')) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                } while (e);\r\n                return features.length > 0 ? features : null;\r\n            },\r\n            prepareAndGetNestableAtRule: function (treeType, index, debugInfo, syntaxOptions) {\r\n                var features = this.mediaFeatures(syntaxOptions);\r\n                var rules = this.block();\r\n                if (!rules) {\r\n                    error('media definitions require block statements after any features');\r\n                }\r\n                parserInput.forget();\r\n                var atRule = new (treeType)(rules, features, index + currentIndex, fileInfo);\r\n                if (context.dumpLineNumbers) {\r\n                    atRule.debugInfo = debugInfo;\r\n                }\r\n                return atRule;\r\n            },\r\n            nestableAtRule: function () {\r\n                var debugInfo;\r\n                var index = parserInput.i;\r\n                if (context.dumpLineNumbers) {\r\n                    debugInfo = getDebugInfo(index);\r\n                }\r\n                parserInput.save();\r\n                if (parserInput.$peekChar('@')) {\r\n                    if (parserInput.$str('@media')) {\r\n                        return this.prepareAndGetNestableAtRule(tree_1.default.Media, index, debugInfo, atrule_syntax_1.MediaSyntaxOptions);\r\n                    }\r\n                    if (parserInput.$str('@container')) {\r\n                        return this.prepareAndGetNestableAtRule(tree_1.default.Container, index, debugInfo, atrule_syntax_1.ContainerSyntaxOptions);\r\n                    }\r\n                }\r\n                parserInput.restore();\r\n            },\r\n            //\r\n            // A @plugin directive, used to import plugins dynamically.\r\n            //\r\n            //     @plugin (args) \"lib\";\r\n            //\r\n            plugin: function () {\r\n                var path;\r\n                var args;\r\n                var options;\r\n                var index = parserInput.i;\r\n                var dir = parserInput.$re(/^@plugin\\s+/);\r\n                if (dir) {\r\n                    args = this.pluginArgs();\r\n                    if (args) {\r\n                        options = {\r\n                            pluginArgs: args,\r\n                            isPlugin: true\r\n                        };\r\n                    }\r\n                    else {\r\n                        options = { isPlugin: true };\r\n                    }\r\n                    if ((path = this.entities.quoted() || this.entities.url())) {\r\n                        if (!parserInput.$char(';')) {\r\n                            parserInput.i = index;\r\n                            error('missing semi-colon on @plugin');\r\n                        }\r\n                        return new (tree_1.default.Import)(path, null, options, index + currentIndex, fileInfo);\r\n                    }\r\n                    else {\r\n                        parserInput.i = index;\r\n                        error('malformed @plugin statement');\r\n                    }\r\n                }\r\n            },\r\n            pluginArgs: function () {\r\n                // list of options, surrounded by parens\r\n                parserInput.save();\r\n                if (!parserInput.$char('(')) {\r\n                    parserInput.restore();\r\n                    return null;\r\n                }\r\n                var args = parserInput.$re(/^\\s*([^);]+)\\)\\s*/);\r\n                if (args[1]) {\r\n                    parserInput.forget();\r\n                    return args[1].trim();\r\n                }\r\n                else {\r\n                    parserInput.restore();\r\n                    return null;\r\n                }\r\n            },\r\n            //\r\n            // A CSS AtRule\r\n            //\r\n            //     @charset \"utf-8\";\r\n            //\r\n            atrule: function () {\r\n                var index = parserInput.i;\r\n                var name;\r\n                var value;\r\n                var rules;\r\n                var nonVendorSpecificName;\r\n                var hasIdentifier;\r\n                var hasExpression;\r\n                var hasUnknown;\r\n                var hasBlock = true;\r\n                var isRooted = true;\r\n                if (parserInput.currentChar() !== '@') {\r\n                    return;\r\n                }\r\n                value = this['import']() || this.plugin() || this.nestableAtRule();\r\n                if (value) {\r\n                    return value;\r\n                }\r\n                parserInput.save();\r\n                name = parserInput.$re(/^@[a-z-]+/);\r\n                if (!name) {\r\n                    return;\r\n                }\r\n                nonVendorSpecificName = name;\r\n                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\r\n                    nonVendorSpecificName = \"@\".concat(name.slice(name.indexOf('-', 2) + 1));\r\n                }\r\n                switch (nonVendorSpecificName) {\r\n                    case '@charset':\r\n                        hasIdentifier = true;\r\n                        hasBlock = false;\r\n                        break;\r\n                    case '@namespace':\r\n                        hasExpression = true;\r\n                        hasBlock = false;\r\n                        break;\r\n                    case '@keyframes':\r\n                    case '@counter-style':\r\n                        hasIdentifier = true;\r\n                        break;\r\n                    case '@document':\r\n                    case '@supports':\r\n                        hasUnknown = true;\r\n                        isRooted = false;\r\n                        break;\r\n                    default:\r\n                        hasUnknown = true;\r\n                        break;\r\n                }\r\n                parserInput.commentStore.length = 0;\r\n                if (hasIdentifier) {\r\n                    value = this.entity();\r\n                    if (!value) {\r\n                        error(\"expected \".concat(name, \" identifier\"));\r\n                    }\r\n                }\r\n                else if (hasExpression) {\r\n                    value = this.expression();\r\n                    if (!value) {\r\n                        error(\"expected \".concat(name, \" expression\"));\r\n                    }\r\n                }\r\n                else if (hasUnknown) {\r\n                    value = this.permissiveValue(/^[{;]/);\r\n                    hasBlock = (parserInput.currentChar() === '{');\r\n                    if (!value) {\r\n                        if (!hasBlock && parserInput.currentChar() !== ';') {\r\n                            error(\"\".concat(name, \" rule is missing block or ending semi-colon\"));\r\n                        }\r\n                    }\r\n                    else if (!value.value) {\r\n                        value = null;\r\n                    }\r\n                }\r\n                if (hasBlock) {\r\n                    rules = this.blockRuleset();\r\n                }\r\n                if (rules || (!hasBlock && value && parserInput.$char(';'))) {\r\n                    parserInput.forget();\r\n                    return new (tree_1.default.AtRule)(name, value, rules, index + currentIndex, fileInfo, context.dumpLineNumbers ? getDebugInfo(index) : null, isRooted);\r\n                }\r\n                parserInput.restore('at-rule options not recognised');\r\n            },\r\n            //\r\n            // A Value is a comma-delimited list of Expressions\r\n            //\r\n            //     font-family: Baskerville, Georgia, serif;\r\n            //\r\n            // In a Rule, a Value represents everything after the `:`,\r\n            // and before the `;`.\r\n            //\r\n            value: function () {\r\n                var e;\r\n                var expressions = [];\r\n                var index = parserInput.i;\r\n                do {\r\n                    e = this.expression();\r\n                    if (e) {\r\n                        expressions.push(e);\r\n                        if (!parserInput.$char(',')) {\r\n                            break;\r\n                        }\r\n                    }\r\n                } while (e);\r\n                if (expressions.length > 0) {\r\n                    return new (tree_1.default.Value)(expressions, index + currentIndex);\r\n                }\r\n            },\r\n            important: function () {\r\n                if (parserInput.currentChar() === '!') {\r\n                    return parserInput.$re(/^! *important/);\r\n                }\r\n            },\r\n            sub: function () {\r\n                var a;\r\n                var e;\r\n                parserInput.save();\r\n                if (parserInput.$char('(')) {\r\n                    a = this.addition();\r\n                    if (a && parserInput.$char(')')) {\r\n                        parserInput.forget();\r\n                        e = new (tree_1.default.Expression)([a]);\r\n                        e.parens = true;\r\n                        return e;\r\n                    }\r\n                    parserInput.restore('Expected \\')\\'');\r\n                    return;\r\n                }\r\n                parserInput.restore();\r\n            },\r\n            multiplication: function () {\r\n                var m;\r\n                var a;\r\n                var op;\r\n                var operation;\r\n                var isSpaced;\r\n                m = this.operand();\r\n                if (m) {\r\n                    isSpaced = parserInput.isWhitespace(-1);\r\n                    while (true) {\r\n                        if (parserInput.peek(/^\\/[*/]/)) {\r\n                            break;\r\n                        }\r\n                        parserInput.save();\r\n                        op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');\r\n                        if (!op) {\r\n                            parserInput.forget();\r\n                            break;\r\n                        }\r\n                        a = this.operand();\r\n                        if (!a) {\r\n                            parserInput.restore();\r\n                            break;\r\n                        }\r\n                        parserInput.forget();\r\n                        m.parensInOp = true;\r\n                        a.parensInOp = true;\r\n                        operation = new (tree_1.default.Operation)(op, [operation || m, a], isSpaced);\r\n                        isSpaced = parserInput.isWhitespace(-1);\r\n                    }\r\n                    return operation || m;\r\n                }\r\n            },\r\n            addition: function () {\r\n                var m;\r\n                var a;\r\n                var op;\r\n                var operation;\r\n                var isSpaced;\r\n                m = this.multiplication();\r\n                if (m) {\r\n                    isSpaced = parserInput.isWhitespace(-1);\r\n                    while (true) {\r\n                        op = parserInput.$re(/^[-+]\\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));\r\n                        if (!op) {\r\n                            break;\r\n                        }\r\n                        a = this.multiplication();\r\n                        if (!a) {\r\n                            break;\r\n                        }\r\n                        m.parensInOp = true;\r\n                        a.parensInOp = true;\r\n                        operation = new (tree_1.default.Operation)(op, [operation || m, a], isSpaced);\r\n                        isSpaced = parserInput.isWhitespace(-1);\r\n                    }\r\n                    return operation || m;\r\n                }\r\n            },\r\n            conditions: function () {\r\n                var a;\r\n                var b;\r\n                var index = parserInput.i;\r\n                var condition;\r\n                a = this.condition(true);\r\n                if (a) {\r\n                    while (true) {\r\n                        if (!parserInput.peek(/^,\\s*(not\\s*)?\\(/) || !parserInput.$char(',')) {\r\n                            break;\r\n                        }\r\n                        b = this.condition(true);\r\n                        if (!b) {\r\n                            break;\r\n                        }\r\n                        condition = new (tree_1.default.Condition)('or', condition || a, b, index + currentIndex);\r\n                    }\r\n                    return condition || a;\r\n                }\r\n            },\r\n            condition: function (needsParens) {\r\n                var result;\r\n                var logical;\r\n                var next;\r\n                function or() {\r\n                    return parserInput.$str('or');\r\n                }\r\n                result = this.conditionAnd(needsParens);\r\n                if (!result) {\r\n                    return;\r\n                }\r\n                logical = or();\r\n                if (logical) {\r\n                    next = this.condition(needsParens);\r\n                    if (next) {\r\n                        result = new (tree_1.default.Condition)(logical, result, next);\r\n                    }\r\n                    else {\r\n                        return;\r\n                    }\r\n                }\r\n                return result;\r\n            },\r\n            conditionAnd: function (needsParens) {\r\n                var result;\r\n                var logical;\r\n                var next;\r\n                var self = this;\r\n                function insideCondition() {\r\n                    var cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);\r\n                    if (!cond && !needsParens) {\r\n                        return self.atomicCondition(needsParens);\r\n                    }\r\n                    return cond;\r\n                }\r\n                function and() {\r\n                    return parserInput.$str('and');\r\n                }\r\n                result = insideCondition();\r\n                if (!result) {\r\n                    return;\r\n                }\r\n                logical = and();\r\n                if (logical) {\r\n                    next = this.conditionAnd(needsParens);\r\n                    if (next) {\r\n                        result = new (tree_1.default.Condition)(logical, result, next);\r\n                    }\r\n                    else {\r\n                        return;\r\n                    }\r\n                }\r\n                return result;\r\n            },\r\n            negatedCondition: function (needsParens) {\r\n                if (parserInput.$str('not')) {\r\n                    var result = this.parenthesisCondition(needsParens);\r\n                    if (result) {\r\n                        result.negate = !result.negate;\r\n                    }\r\n                    return result;\r\n                }\r\n            },\r\n            parenthesisCondition: function (needsParens) {\r\n                function tryConditionFollowedByParenthesis(me) {\r\n                    var body;\r\n                    parserInput.save();\r\n                    body = me.condition(needsParens);\r\n                    if (!body) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                    if (!parserInput.$char(')')) {\r\n                        parserInput.restore();\r\n                        return;\r\n                    }\r\n                    parserInput.forget();\r\n                    return body;\r\n                }\r\n                var body;\r\n                parserInput.save();\r\n                if (!parserInput.$str('(')) {\r\n                    parserInput.restore();\r\n                    return;\r\n                }\r\n                body = tryConditionFollowedByParenthesis(this);\r\n                if (body) {\r\n                    parserInput.forget();\r\n                    return body;\r\n                }\r\n                body = this.atomicCondition(needsParens);\r\n                if (!body) {\r\n                    parserInput.restore();\r\n                    return;\r\n                }\r\n                if (!parserInput.$char(')')) {\r\n                    parserInput.restore(\"expected ')' got '\".concat(parserInput.currentChar(), \"'\"));\r\n                    return;\r\n                }\r\n                parserInput.forget();\r\n                return body;\r\n            },\r\n            atomicCondition: function (needsParens, preparsedCond) {\r\n                var entities = this.entities;\r\n                var index = parserInput.i;\r\n                var a;\r\n                var b;\r\n                var c;\r\n                var op;\r\n                var cond = (function () {\r\n                    return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();\r\n                }).bind(this);\r\n                if (preparsedCond) {\r\n                    a = preparsedCond;\r\n                }\r\n                else {\r\n                    a = cond();\r\n                }\r\n                if (a) {\r\n                    if (parserInput.$char('>')) {\r\n                        if (parserInput.$char('=')) {\r\n                            op = '>=';\r\n                        }\r\n                        else {\r\n                            op = '>';\r\n                        }\r\n                    }\r\n                    else if (parserInput.$char('<')) {\r\n                        if (parserInput.$char('=')) {\r\n                            op = '<=';\r\n                        }\r\n                        else {\r\n                            op = '<';\r\n                        }\r\n                    }\r\n                    else if (parserInput.$char('=')) {\r\n                        if (parserInput.$char('>')) {\r\n                            op = '=>';\r\n                        }\r\n                        else if (parserInput.$char('<')) {\r\n                            op = '=<';\r\n                        }\r\n                        else {\r\n                            op = '=';\r\n                        }\r\n                    }\r\n                    if (op) {\r\n                        b = cond();\r\n                        if (b) {\r\n                            c = new (tree_1.default.Condition)(op, a, b, index + currentIndex, false);\r\n                        }\r\n                        else {\r\n                            error('expected expression');\r\n                        }\r\n                    }\r\n                    else if (!preparsedCond) {\r\n                        c = new (tree_1.default.Condition)('=', a, new (tree_1.default.Keyword)('true'), index + currentIndex, false);\r\n                    }\r\n                    return c;\r\n                }\r\n            },\r\n            //\r\n            // An operand is anything that can be part of an operation,\r\n            // such as a Color, or a Variable\r\n            //\r\n            operand: function () {\r\n                var entities = this.entities;\r\n                var negate;\r\n                if (parserInput.peek(/^-[@$(]/)) {\r\n                    negate = parserInput.$char('-');\r\n                }\r\n                var o = this.sub() || entities.dimension() ||\r\n                    entities.color() || entities.variable() ||\r\n                    entities.property() || entities.call() ||\r\n                    entities.quoted(true) || entities.colorKeyword() ||\r\n                    entities.mixinLookup();\r\n                if (negate) {\r\n                    o.parensInOp = true;\r\n                    o = new (tree_1.default.Negative)(o);\r\n                }\r\n                return o;\r\n            },\r\n            //\r\n            // Expressions either represent mathematical operations,\r\n            // or white-space delimited Entities.\r\n            //\r\n            //     1px solid black\r\n            //     @var * 2\r\n            //\r\n            expression: function () {\r\n                var entities = [];\r\n                var e;\r\n                var delim;\r\n                var index = parserInput.i;\r\n                do {\r\n                    e = this.comment();\r\n                    if (e) {\r\n                        entities.push(e);\r\n                        continue;\r\n                    }\r\n                    e = this.addition() || this.entity();\r\n                    if (e instanceof tree_1.default.Comment) {\r\n                        e = null;\r\n                    }\r\n                    if (e) {\r\n                        entities.push(e);\r\n                        // operations do not allow keyword \"/\" dimension (e.g. small/20px) so we support that here\r\n                        if (!parserInput.peek(/^\\/[/*]/)) {\r\n                            delim = parserInput.$char('/');\r\n                            if (delim) {\r\n                                entities.push(new (tree_1.default.Anonymous)(delim, index + currentIndex));\r\n                            }\r\n                        }\r\n                    }\r\n                } while (e);\r\n                if (entities.length > 0) {\r\n                    return new (tree_1.default.Expression)(entities);\r\n                }\r\n            },\r\n            property: function () {\r\n                var name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/);\r\n                if (name) {\r\n                    return name[1];\r\n                }\r\n            },\r\n            ruleProperty: function () {\r\n                var name = [];\r\n                var index = [];\r\n                var s;\r\n                var k;\r\n                parserInput.save();\r\n                var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/);\r\n                if (simpleProperty) {\r\n                    name = [new (tree_1.default.Keyword)(simpleProperty[1])];\r\n                    parserInput.forget();\r\n                    return name;\r\n                }\r\n                function match(re) {\r\n                    var i = parserInput.i;\r\n                    var chunk = parserInput.$re(re);\r\n                    if (chunk) {\r\n                        index.push(i);\r\n                        return name.push(chunk[1]);\r\n                    }\r\n                }\r\n                match(/^(\\*?)/);\r\n                while (true) {\r\n                    if (!match(/^((?:[\\w-]+)|(?:[@$]\\{[\\w-]+\\}))/)) {\r\n                        break;\r\n                    }\r\n                }\r\n                if ((name.length > 1) && match(/^((?:\\+_|\\+)?)\\s*:/)) {\r\n                    parserInput.forget();\r\n                    // at last, we have the complete match now. move forward,\r\n                    // convert name particles to tree objects and return:\r\n                    if (name[0] === '') {\r\n                        name.shift();\r\n                        index.shift();\r\n                    }\r\n                    for (k = 0; k < name.length; k++) {\r\n                        s = name[k];\r\n                        name[k] = (s.charAt(0) !== '@' && s.charAt(0) !== '$') ?\r\n                            new (tree_1.default.Keyword)(s) :\r\n                            (s.charAt(0) === '@' ?\r\n                                new (tree_1.default.Variable)(\"@\".concat(s.slice(2, -1)), index[k] + currentIndex, fileInfo) :\r\n                                new (tree_1.default.Property)(\"$\".concat(s.slice(2, -1)), index[k] + currentIndex, fileInfo));\r\n                    }\r\n                    return name;\r\n                }\r\n                parserInput.restore();\r\n            }\r\n        }\r\n    };\r\n};\r\nParser.serializeVars = function (vars) {\r\n    var s = '';\r\n    for (var name_1 in vars) {\r\n        if (Object.hasOwnProperty.call(vars, name_1)) {\r\n            var value = vars[name_1];\r\n            s += \"\".concat(((name_1[0] === '@') ? '' : '@') + name_1, \": \").concat(value).concat((String(value).slice(-1) === ';') ? '' : ';');\r\n        }\r\n    }\r\n    return s;\r\n};\r\nexports.default = Parser;\r\n//# sourceMappingURL=parser.js.map"]}